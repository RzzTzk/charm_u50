#!/usr/bin/env python3
import json
import os
from jinja2 import Template

# HLS代码模板（使用Jinja2）
KERNEL_TEMPLATE = """// Auto-generated by CHARM CDSE
#include "utils.h"

#define TILE_M {{tile_m}}
#define TILE_N {{tile_n}}
#define TILE_K {{tile_k}}
#define DSP_PER_PE {{dsp_per_pe}}

extern "C" {
void {{kernel_name}}(
    const float* A,  // HBM通道{{hbm_start}}-{{hbm_start+hbm_channels//2-1}}
    const float* B,  // HBM通道{{hbm_start+hbm_channels//2}}-{{hbm_start+hbm_channels-1}}
    float* C,        // 复用A的通道
    int M, int K, int N
) {
    #pragma HLS INTERFACE m_axi port=A offset=slave bundle=gmem{% if is_large %}0{% else %}1{% endif %} num_read_outstanding=32
    #pragma HLS INTERFACE m_axi port=B offset=slave bundle=gmem{% if is_large %}1{% else %}2{% endif %} num_read_outstanding=32
    #pragma HLS INTERFACE m_axi port=C offset=slave bundle=gmem{% if is_large %}0{% else %}1{% endif %} num_write_outstanding=32
    #pragma HLS INTERFACE s_axilite port=return
    {% if is_large %}
    #pragma HLS DATAFLOW
    {% endif %}

    // 本地缓存配置
    float local_A[TILE_M][TILE_K];
    float local_B[TILE_K][TILE_N];
    float local_C[TILE_M][TILE_N] = {0};
    
    #pragma HLS ARRAY_PARTITION variable=local_A cyclic factor={{partition_factor}} dim=1
    #pragma HLS ARRAY_PARTITION variable=local_B cyclic factor={{partition_factor}} dim=2
    #pragma HLS BIND_STORAGE variable=local_A type=ram_2p impl={% if is_large %}uram{% else %}bram{% endif %}
    #pragma HLS BIND_STORAGE variable=local_B type=ram_2p impl={% if is_large %}uram{% else %}bram{% endif %}

    // 计算逻辑
    {% if is_large %}
    // 大矩阵分块计算
    for (int ti = 0; ti < M; ti += TILE_M) {
        for (int tj = 0; tj < N; tj += TILE_N) {
            #pragma HLS LOOP_FLATTEN
            read_block(A + ti*K, local_A, TILE_M, TILE_K, K);
            read_block(B + tj, local_B, TILE_K, TILE_N, N);

            for (int tk = 0; tk < K; tk += TILE_K) {
                for (int i = 0; i < TILE_M; i++) {
                    for (int j = 0; j < TILE_N; j++) {
                        #pragma HLS PIPELINE II=1
                        float sum = local_C[i][j];
                        for (int k = 0; k < TILE_K; k++) {
                            sum += local_A[i][k] * local_B[k][j];
                        }
                        local_C[i][j] = sum;
                    }
                }
            }
            write_block(C + ti*N + tj, local_C, TILE_M, TILE_N, N);
        }
    }
    {% else %}
    // 小矩阵流式计算
    hls::stream<float> a_stream("a_stream");
    hls::stream<float> b_stream("b_stream");
    
    load_A: for(int i = 0; i < M*K; i++) {
        #pragma HLS PIPELINE II=1
        a_stream.write(A[i]);
    }
    load_B: for(int i = 0; i < K*N; i++) {
        #pragma HLS PIPELINE II=1
        b_stream.write(B[i]);
    }

    compute: for(int i = 0; i < M; i++) {
        for(int j = 0; j < N; j++) {
            #pragma HLS PIPELINE II=1
            float sum = 0;
            for(int k = 0; k < K; k++) {
                sum += a_stream.read() * b_stream.read();
            }
            C[i*N + j] = sum;
        }
    }
    {% endif %}
}
}
"""

def generate_hls_code(config_file):
    # 加载加速器配置
    with open(config_file) as f:
        config = json.load(f)
    
    # 创建输出目录
    os.makedirs("kernels", exist_ok=True)
    
    # 生成公共头文件
    with open("kernels/utils.h", "w") as f:
        f.write("""#ifndef _UTILS_H_
#define _UTILS_H_

#include <ap_int.h>
#include <hls_stream.h>

template<typename T, int DIM1, int DIM2>
void read_block(const T* src, T dst[DIM1][DIM2], int rows, int cols, int ld) {
    for (int i = 0; i < rows; i++) {
        #pragma HLS PIPELINE II=1
        for (int j = 0; j < cols; j++) {
            dst[i][j] = src[i*ld + j];
        }
    }
}

template<typename T, int DIM1, int DIM2>
void write_block(T* dst, const T src[DIM1][DIM2], int rows, int cols, int ld) {
    for (int i = 0; i < rows; i++) {
        #pragma HLS PIPELINE II=1
        for (int j = 0; j < cols; j++) {
            dst[i*ld + j] = src[i][j];
        }
    }
}

#endif
""")
    
    # 为每个加速器生成代码
    for i, acc in enumerate(config["accelerators"]):
        is_large = acc["type"] == "large"
        template_vars = {
            "kernel_name": f"mm_{acc['type']}",
            "tile_m": acc["tile"][0],
            "tile_n": acc["tile"][1],
            "tile_k": acc["tile"][2],
            "dsp_per_pe": 4 if is_large else 2,
            "hbm_start": acc["hbm_channels"]["start"],
            "hbm_channels": acc["hbm_channels"]["count"],
            "partition_factor": min(32, acc["tile"][0]//4) if is_large else 1,
            "is_large": is_large
        }
        
        # 渲染模板
        code = Template(KERNEL_TEMPLATE).render(template_vars)
        
        # 写入文件
        filename = f"kernels/mm_{acc['type']}.cpp"
        with open(filename, "w") as f:
            f.write(code)
        print(f"Generated {filename} with tile={acc['tile']} DSP={acc['dsp']}")

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--config", required=True, help="Path to acc_config.json")
    args = parser.parse_args()
    
    generate_hls_code(args.config)