// Auto-generated by CHARM CDSE
#define TILE_M 64
#define TILE_N 64
#define TILE_K 64
#define DSP_PER_PE 2

extern "C" {
void mm_small(
    const float* A,  // HBM通道24-27
    const float* B,  // HBM通道28-31
    float* C,        // 复用A的通道
    int M, int K, int N
) {
    #pragma HLS INTERFACE m_axi port=A offset=slave bundle=gmem1 num_read_outstanding=32
    #pragma HLS INTERFACE m_axi port=B offset=slave bundle=gmem2 num_read_outstanding=32
    #pragma HLS INTERFACE m_axi port=C offset=slave bundle=gmem1 num_write_outstanding=32
    #pragma HLS INTERFACE s_axilite port=return
    

    // 本地缓存配置
    float local_A[TILE_M][TILE_K];
    float local_B[TILE_K][TILE_N];
    float local_C[TILE_M][TILE_N] = {0};
    
    #pragma HLS ARRAY_PARTITION variable=local_A cyclic factor=1 dim=1
    #pragma HLS ARRAY_PARTITION variable=local_B cyclic factor=1 dim=2
    #pragma HLS BIND_STORAGE variable=local_A type=ram_2p impl=bram
    #pragma HLS BIND_STORAGE variable=local_B type=ram_2p impl=bram

    // 计算逻辑
    
    // 小矩阵流式计算
    hls::stream<float> a_stream("a_stream");
    hls::stream<float> b_stream("b_stream");
    
    load_A: for(int i = 0; i < M*K; i++) {
        #pragma HLS PIPELINE II=1
        a_stream.write(A[i]);
    }
    load_B: for(int i = 0; i < K*N; i++) {
        #pragma HLS PIPELINE II=1
        b_stream.write(B[i]);
    }

    compute: for(int i = 0; i < M; i++) {
        for(int j = 0; j < N; j++) {
            #pragma HLS PIPELINE II=1
            float sum = 0;
            for(int k = 0; k < K; k++) {
                sum += a_stream.read() * b_stream.read();
            }
            C[i*N + j] = sum;
        }
    }
    
}
}