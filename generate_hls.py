#!/usr/bin/env python3
"""
Auto-HLS Code Generator for CHARM U50 Project
Usage: 
  python generate_hls.py --config design_space/acc_config.json
"""

import json
import os
from pathlib import Path
from jinja2 import Template

# --- Configuration ---
PROJECT_ROOT = Path(__file__).parent.resolve()
KERNEL_DIR = PROJECT_ROOT / "kernels"
INCLUDE_DIR = PROJECT_ROOT / "include" / "kernel"
BUILD_DIR = PROJECT_ROOT / "build"
TEMPLATE_DIR = PROJECT_ROOT / "scripts" / "templates"

# --- Template for HLS Kernels ---
KERNEL_TEMPLATE = """// Auto-generated by CHARM CDSE
#include "utils.h"  // From kernel-specific include dir

#define TILE_M {{tile_m}}
#define TILE_N {{tile_n}}
#define TILE_K {{tile_k}}
#define DSP_PER_PE {{dsp_per_pe}}

extern "C" {
void {{kernel_name}}(
    const float* A,  // HBM channel {{hbm_start}} to {{hbm_end}}
    const float* B,  // HBM channel {{hbm_b_start}} to {{hbm_b_end}}
    float* C,
    int M, int K, int N
) {
    #pragma HLS INTERFACE m_axi port=A offset=slave bundle=gmem{{bundle_a}}
    #pragma HLS INTERFACE m_axi port=B offset=slave bundle=gmem{{bundle_b}}
    #pragma HLS INTERFACE m_axi port=C offset=slave bundle=gmem{{bundle_a}}
    #pragma HLS INTERFACE s_axilite port=return
    {{dataflow_pragma}}

    // Local buffers
    float local_A[TILE_M][TILE_K];
    float local_B[TILE_K][TILE_N];
    #pragma HLS ARRAY_PARTITION variable=local_A cyclic factor={{partition_factor}} dim=1
    #pragma HLS ARRAY_PARTITION variable=local_B cyclic factor={{partition_factor}} dim=2
    #pragma HLS BIND_STORAGE variable=local_A type=ram_2p impl={{mem_type}}
    #pragma HLS BIND_STORAGE variable=local_B type=ram_2p impl={{mem_type}}

    // Main computation
    {% if is_large %}
    // Large matrix tiling
    for (int ti = 0; ti < M; ti += TILE_M) {
        for (int tj = 0; tj < N; tj += TILE_N) {
            #pragma HLS LOOP_FLATTEN
            read_block<float, TILE_M, TILE_K>(A + ti*K, local_A, TILE_M, TILE_K, K);
            read_block<float, TILE_K, TILE_N>(B + tj, local_B, TILE_K, TILE_N, N);

            for (int tk = 0; tk < K; tk += TILE_K) {
                for (int i = 0; i < TILE_M; i++) {
                    for (int j = 0; j < TILE_N; j++) {
                        #pragma HLS PIPELINE II=1
                        float sum = 0;
                        for (int k = 0; k < TILE_K; k++) {
                            sum += local_A[i][k] * local_B[k][j];
                        }
                        C[(ti+i)*N + (tj+j)] = sum;
                    }
                }
            }
        }
    }
    {% else %}
    // Small matrix streaming
    hls::stream<float> a_stream, b_stream;
    #pragma HLS STREAM variable=a_stream depth={{fifo_depth}}
    #pragma HLS STREAM variable=b_stream depth={{fifo_depth}}

    load_A: for(int i = 0; i < M*K; i++) {
        #pragma HLS PIPELINE II=1
        a_stream.write(A[i]);
    }

    load_B: for(int i = 0; i < K*N; i++) {
        #pragma HLS PIPELINE II=1
        b_stream.write(B[i]);
    }

    compute: for(int i = 0; i < M; i++) {
        for(int j = 0; j < N; j++) {
            #pragma HLS PIPELINE II=1
            float sum = 0;
            for(int k = 0; k < K; k++) {
                sum += a_stream.read() * b_stream.read();
            }
            C[i*N + j] = sum;
        }
    }
    {% endif %}
}
}
"""

def generate_hls_code(config_file):
    """Generate HLS kernels from configuration"""
    try:
        with open(config_file) as f:
            config = json.load(f)
    except Exception as e:
        print(f"Error loading config: {e}")
        return

    # Create directories
    (INCLUDE_DIR).mkdir(parents=True, exist_ok=True)
    (BUILD_DIR).mkdir(exist_ok=True)

    # Generate kernel utils header
    utils_header = INCLUDE_DIR / "utils.h"
    with open(utils_header, "w") as f:
        f.write("""#ifndef KERNEL_UTILS_H
#define KERNEL_UTILS_H

#include <ap_int.h>
#include <hls_stream.h>

template<typename T, int DIM1, int DIM2>
void read_block(const T* src, T dst[DIM1][DIM2], int rows, int cols, int ld) {
    #pragma HLS INLINE
    for (int i = 0; i < rows; i++) {
        #pragma HLS PIPELINE II=1
        for (int j = 0; j < cols; j++) {
            dst[i][j] = src[i*ld + j];
        }
    }
}

template<typename T, int DIM1, int DIM2>
void write_block(T* dst, const T src[DIM1][DIM2], int rows, int cols, int ld) {
    #pragma HLS INLINE
    for (int i = 0; i < rows; i++) {
        #pragma HLS PIPELINE II=1
        for (int j = 0; j < cols; j++) {
            dst[i*ld + j] = src[i][j];
        }
    }
}

#endif
""")
    print(f"Generated {utils_header}")

    # Generate each accelerator kernel
    for acc in config["accelerators"]:
        is_large = acc["type"] == "large"
        template_vars = {
            "kernel_name": f"mm_{acc['type']}",
            "tile_m": acc["tile"][0],
            "tile_n": acc["tile"][1],
            "tile_k": acc["tile"][2],
            "dsp_per_pe": 4 if is_large else 2,
            "hbm_start": acc["hbm_channels"]["start"],
            "hbm_end": acc["hbm_channels"]["start"] + acc["hbm_channels"]["count"] // 2 - 1,
            "hbm_b_start": acc["hbm_channels"]["start"] + acc["hbm_channels"]["count"] // 2,
            "hbm_b_end": acc["hbm_channels"]["start"] + acc["hbm_channels"]["count"] - 1,
            "bundle_a": 0 if is_large else 1,
            "bundle_b": 1 if is_large else 2,
            "partition_factor": min(32, acc["tile"][0]//4) if is_large else 1,
            "mem_type": "uram" if is_large else "bram",
            "fifo_depth": 32 if not is_large else 0,
            "dataflow_pragma": "#pragma HLS DATAFLOW" if is_large else "",
            "is_large": is_large
        }

        # Render and save kernel
        kernel_code = Template(KERNEL_TEMPLATE).render(template_vars)
        kernel_path = KERNEL_DIR / f"mm_{acc['type']}.cpp"
        
        with open(kernel_path, "w") as f:
            f.write(kernel_code)
        print(f"Generated {kernel_path} with tile={acc['tile']}")

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Generate HLS kernels from config")
    parser.add_argument("--config", required=True, help="Path to acc_config.json")
    args = parser.parse_args()
    
    generate_hls_code(args.config)